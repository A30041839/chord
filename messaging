In C-Share, the messaging system is responsible for remote function call and data transfer among different nodes. There are two categories of messages: RPC messages and Data messages. RPC messages are created when a node wants to call a function on a remote node and retrieve return value of that call. For example, if node i want node j to find the successor of key k, node i will call findSuccessor(k) on node j remotely. We use gRPC to implement this remote function call. Firstly, we need to write a .proto file to define the message type and structure as well as declare the protocol of remote function calls. Secondly, each node runs a gRPC server in a independent thread, listening to incoming calls. The server will extract parameters of the incomming calls, do some calculation, generate response and send it back to caller node. Finally, each node has a gRPC client class which defines all types of remote function call as its member functions. Back to our previous example, when node i want to call findSuccessor(k) on node j remotely, it will first connect to node j and get an object of gRPC client class. Then node j will call the member function findSuccessor(k) in this object and get the return value of it. In fact, the parameters and remote function name are all serialized and send to destination node via socket. The destination node deserializes it, demultiplexs it and calls the corresponding function calls with received parameters. Finally, the destination node retrive the return value of the function call, serialize it and send it back to previously built socket. The source node deserializes the return value and the whole process is finished. All of these works are transparent to users and implemented by gRPC. 

.proto file example 

// Interface exported by the server.
service Messager { 
  rpc getPredecessor(m_void) returns (m_node_t) {}
  rpc setPredecessor(m_node_t) returns (m_void) {}
  rpc getSuccessor(m_void) returns (m_node_t) {}
  rpc findSuccessor(m_int) returns (m_node_t) {}
  rpc findClosestPrecedingFinger(m_int) returns (m_node_t) {}
  rpc updateFingerTable(m_node_t_int) returns (m_void) {}
  rpc removeNode(m_node_t_node_t_int) returns (m_void) {}
}

// void reply
message m_void{
  
}
message m_int{
  int64 id = 1;
}
message m_node_t {
  string hostname = 1;
  int64 id = 2;
  int32 portno = 3;
  string machine_name = 4;
}
message m_node_t_int{
  m_node_t node = 1;
  int64 id = 2;
}
message m_node_t_node_t_int{
  m_node_t node_1 = 1;
  m_node_t node_2 = 2;
  int64 id = 3;
}


